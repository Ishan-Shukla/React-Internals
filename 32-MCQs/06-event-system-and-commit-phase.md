# MCQs: Event System & Commit Phase

---

### Q1. Where does React attach event listeners in React 18+?
- A) On each individual DOM element
- B) On the root container element (`createRoot` target)
- C) On `document`
- D) On `window`

**Answer: B**
React 18 attaches a single listener for each event type on the root container element. React 17 moved from `document` to the root container to support multiple React roots.

---

### Q2. What is React's event delegation pattern?
- A) Each component delegates events to its parent
- B) One listener at the root captures all events and dispatches them to the correct fiber
- C) Events are delegated to Web Workers
- D) Events are delegated to the Scheduler

**Answer: B**
React registers one listener per event type at the root. When a native event fires, React finds the target fiber and walks the fiber tree collecting matching handlers.

---

### Q3. How does React find the fiber for an event target DOM node?
- A) Searches the entire fiber tree
- B) Uses `event.target.__reactFiber$` (an internal property cached on DOM nodes)
- C) Queries React DevTools
- D) Uses CSS selectors

**Answer: B**
React stores a reference to the fiber on each DOM node via an internal property like `__reactFiber$<randomKey>`. This is called "precaching" the fiber node.

---

### Q4. What is a SyntheticEvent?
- A) An artificial event generated by React for testing
- B) A cross-browser wrapper around the native DOM event
- C) A CSS animation event
- D) A server-generated event

**Answer: B**
SyntheticEvent normalizes browser differences in event objects. It wraps the native event and provides a consistent interface with `nativeEvent` access.

---

### Q5. In React 17+, is SyntheticEvent pooling still used?
- A) Yes, for performance
- B) No, pooling was removed in React 17
- C) Only in production builds
- D) Only for touch events

**Answer: B**
Event pooling was removed in React 17. SyntheticEvent objects now persist after the handler returns, eliminating the need for `e.persist()`.

---

### Q6. How does React map events to priorities?
- A) All events have the same priority
- B) Discrete events → SyncLane; Continuous events → InputContinuousLane; Default events → DefaultLane
- C) Priority is based on the event target element
- D) Priority is user-configured

**Answer: B**
Click/keydown → `DiscreteEventPriority` (SyncLane). Mousemove/scroll → `ContinuousEventPriority`. Load/error → `DefaultEventPriority`.

---

### Q7. Which events does React register as passive by default?
- A) click and keydown
- B) touchstart, touchmove, and wheel
- C) All events
- D) None

**Answer: B**
`touchstart`, `touchmove`, and `wheel` are registered as passive for better scroll performance. This means `preventDefault()` won't work in React handlers for these events.

---

### Q8. What happens when you call `e.stopPropagation()` in a React event handler?
- A) Stops native DOM event propagation
- B) Stops React's fiber-tree event propagation (doesn't stop native propagation)
- C) Stops both React and native propagation
- D) Has no effect

**Answer: C**
React's `stopPropagation` calls the native `stopPropagation` on the underlying event AND stops React from walking further up the fiber tree collecting handlers.

---

### Q9. Do events from Portals bubble through the fiber tree or the DOM tree?
- A) DOM tree only
- B) Fiber tree (to the component that created the portal, not the DOM parent)
- C) Both trees independently
- D) Neither — portal events don't bubble

**Answer: B**
React events bubble through the fiber tree. A click inside a portal bubbles to the portal's fiber parent (the component that rendered the portal), not its DOM parent.

---

### Q10. What are the three sub-phases of the commit phase?
- A) Create, Update, Delete
- B) Before Mutation, Mutation, Layout
- C) Mount, Update, Unmount
- D) Prepare, Execute, Finalize

**Answer: B**
1. **Before Mutation**: read DOM state (getSnapshotBeforeUpdate)
2. **Mutation**: apply DOM changes (insert, update, delete)
3. **Layout**: run layout effects, attach refs, component lifecycle

---

### Q11. In which commit sub-phase are DOM mutations applied?
- A) Before Mutation
- B) Mutation
- C) Layout
- D) Passive

**Answer: B**
The Mutation sub-phase is where actual DOM operations occur: `commitPlacement` (insert), `commitUpdate` (modify), `commitDeletion` (remove).

---

### Q12. In which commit sub-phase does `useLayoutEffect` run?
- A) Before Mutation
- B) Mutation
- C) Layout
- D) Passive

**Answer: C**
`useLayoutEffect` setup and cleanup functions run in the Layout sub-phase, after DOM mutations but before the browser paints.

---

### Q13. When do passive effects (`useEffect`) run?
- A) During the Layout sub-phase
- B) Synchronously after commit
- C) Asynchronously after commit, typically after the browser paints
- D) Before the render phase

**Answer: C**
Passive effects are scheduled asynchronously after the commit phase completes. The browser may paint before they run, which is why `useEffect` can't prevent flicker.

---

### Q14. In what order do `useLayoutEffect` cleanups run across the component tree?
- A) Top-down (parent first)
- B) Bottom-up (child first)
- C) Random
- D) Alphabetical

**Answer: B**
Layout effect cleanups and setups run bottom-up (child first, then parent), following the order set by `completeWork`.

---

### Q15. What does `commitPlacement` do?
- A) Places the component in the scheduler
- B) Inserts or moves the fiber's DOM node into the correct position in the DOM
- C) Places context on the stack
- D) Assigns a position to the fiber

**Answer: B**
`commitPlacement` finds the parent DOM node and the correct sibling (via `getHostSibling`), then calls `parentNode.insertBefore(node, sibling)` or `parentNode.appendChild(node)`.

---

### Q16. What does `commitDeletion` process?
- A) Only the top-level DOM node
- B) The entire subtree: detaches refs, runs cleanup effects, removes DOM nodes
- C) Only the fiber node
- D) Only effects

**Answer: B**
`commitDeletion` recursively walks the deleted fiber's subtree to: detach refs, run layout effect cleanups synchronously, schedule passive effect cleanups, then remove the top-level DOM node.

---

### Q17. When are refs attached during commit?
- A) During Before Mutation
- B) During Mutation
- C) During Layout (after DOM mutations, before paint)
- D) During Passive effects

**Answer: C**
`commitAttachRef` runs in the Layout sub-phase. By this point, DOM nodes exist and are in the document, so refs correctly point to the actual DOM elements.

---

### Q18. What is `getSnapshotBeforeUpdate` used for?
- A) Taking a screenshot of the page
- B) Reading DOM state (like scroll position) BEFORE mutations, passing it to `componentDidUpdate`
- C) Snapshotting component state
- D) Creating a backup of the fiber tree

**Answer: B**
This class lifecycle method runs in the Before Mutation sub-phase. It returns a value that's passed as the third argument to `componentDidUpdate`.

---

### Q19. When does the fiber tree swap happen?
- A) At the beginning of commit
- B) After Mutation, before Layout
- C) After all sub-phases complete
- D) During render

**Answer: B**
`root.current = finishedWork` happens after DOM mutations but before layout effects. This ensures `componentDidMount`/`useLayoutEffect` see the new tree as current.

---

### Q20. What does `commitUpdate(instance, updatePayload, type, oldProps, newProps)` do?
- A) Updates the fiber tree
- B) Applies the pre-computed property changes to the DOM element
- C) Updates the component's state
- D) Updates the Scheduler task

**Answer: B**
`commitUpdate` takes the `updatePayload` (array of changed prop names and values from `diffProperties`) and applies them to the DOM node.

---

### Q21. Can the commit phase be interrupted?
- A) Yes, just like the render phase
- B) No, commit is synchronous and uninterruptible
- C) Only in concurrent mode
- D) Only by higher-priority updates

**Answer: B**
The commit phase is always synchronous. Once it starts, all DOM mutations, layout effects, and tree swaps complete before yielding to the browser.

---

### Q22. What happens if a `useLayoutEffect` throws an error?
- A) The commit is rolled back
- B) The error is captured via `captureCommitPhaseError` and processed by the nearest error boundary
- C) The browser crashes
- D) The error is silently ignored

**Answer: B**
Errors in layout effects are caught by `captureCommitPhaseError`. The commit continues (other layout effects still run), and the error boundary processes the error in a new render.

---

### Q23. What is the `Snapshot` flag on a fiber?
- A) Indicates a screenshot should be taken
- B) Indicates the fiber's class component has `getSnapshotBeforeUpdate`
- C) Indicates the fiber has been snapshotted for debugging
- D) Indicates immutable state

**Answer: B**
The `Snapshot` flag is set during render for class components that implement `getSnapshotBeforeUpdate`. During commit's Before Mutation phase, it triggers the snapshot call.

---

### Q24. How does React handle focus management during commit?
- A) Focus is always lost and must be manually restored
- B) React saves the focused element before mutations and restores focus after if needed
- C) React never manages focus
- D) Focus is managed by the browser automatically

**Answer: B**
React saves `document.activeElement` before mutations. If the focused element is removed or replaced, React attempts to restore focus to the appropriate element.

---

### Q25. What is the `ChildDeletion` flag?
- A) All children of this fiber should be deleted
- B) This fiber has children in its `deletions` array that need to be committed
- C) This fiber is a deleted child
- D) This fiber's child count changed

**Answer: B**
`ChildDeletion` indicates the fiber's `deletions` array is non-empty. During commit, `commitDeletionEffects` processes each fiber in the array.

---

### Q26. How does React handle `onScroll` events?
- A) Via delegation at the root like other events
- B) As a non-delegated event registered directly on the target element
- C) Via `IntersectionObserver`
- D) Via polling

**Answer: B**
`scroll` doesn't bubble in the DOM, so React registers it directly on the target element rather than using delegation at the root.

---

### Q27. What does `commitBeforeMutationEffects` do?
- A) Prepares DOM elements for removal
- B) Calls `getSnapshotBeforeUpdate` for class components with the `Snapshot` flag
- C) Runs all mutations
- D) Cleans up passive effects

**Answer: B**
The Before Mutation phase processes fibers with the `Snapshot` flag, calling `getSnapshotBeforeUpdate` which can read DOM state before it changes.

---

### Q28. What is the `ContentReset` flag?
- A) Resets CSS content property
- B) Indicates a text container needs its text content reset before children are appended
- C) Resets the component to initial state
- D) Clears the content cache

**Answer: B**
When a text-only container gets child elements (or vice versa), `ContentReset` ensures the old text content is cleared before new children are inserted.

---

### Q29. How does React handle `dangerouslySetInnerHTML` during commit?
- A) It's handled during render
- B) During mutation sub-phase, it directly sets `innerHTML` on the DOM node
- C) It creates child fibers for the HTML content
- D) It uses a sandboxed iframe

**Answer: B**
`commitUpdate` checks for `dangerouslySetInnerHTML` in the update payload and calls `node.innerHTML = html.__html` directly during the mutation sub-phase.

---

### Q30. What does `commitLayoutEffects` include?
- A) CSS layout calculations
- B) `useLayoutEffect` setup, `componentDidMount/Update`, ref attachment
- C) DOM positioning
- D) Grid/Flexbox layout

**Answer: B**
The Layout sub-phase runs: `useLayoutEffect` setups, `componentDidMount`, `componentDidUpdate`, `commitAttachRef`, and callback refs.

---

### Q31. Why does React separate passive effects from layout effects?
- A) No reason — they could be combined
- B) Layout effects must run before paint (for measurements); passive effects can defer (for subscriptions/fetching)
- C) Passive effects are for class components
- D) Layout effects are slower

**Answer: B**
Layout effects block painting — they're for DOM reads/writes that must happen before the user sees the update. Passive effects don't need to block paint, so deferring them improves performance.

---

### Q32. What does `safelyCallDestroy` do?
- A) Destroys a fiber safely
- B) Wraps effect cleanup function calls in try/catch to handle errors gracefully
- C) Safely removes DOM nodes
- D) Destroys the scheduler task

**Answer: B**
`safelyCallDestroy(current, nearestMountedAncestor, destroy)` calls the cleanup function in a try/catch. If it throws, the error is captured and handled by error boundaries.

---

### Q33. What happens to `setState` calls made after a component unmounts in React 18?
- A) An error is thrown
- B) A warning is logged (like React 17)
- C) The call is silently ignored — no warning, no error
- D) The state is queued for when the component remounts

**Answer: C**
React 18 removed the "Can't perform a React state update on an unmounted component" warning. `setState` on unmounted fibers is a no-op — React finds no root and returns silently.

---

### Q34. What does the `Callback` flag indicate?
- A) The fiber has a callback ref
- B) The fiber has `setState(value, callback)` or `this.forceUpdate(callback)` that needs to fire
- C) The fiber is a callback function
- D) The event callback needs updating

**Answer: B**
For class components, `setState(value, callback)` passes a callback. The `Callback` flag ensures the callback is executed during commit's Layout phase.

---

### Q35. What is the purpose of `schedulePassiveEffects`?
- A) Schedules CSS transitions
- B) Enqueues passive effect flags for deferred processing via `flushPassiveEffects`
- C) Schedules passive event listeners
- D) Schedules idle callbacks

**Answer: B**
During commit, React identifies fibers with passive effect flags and schedules `flushPassiveEffects` via a low-priority Scheduler callback to run after paint.

---

### Q36. What does `commitReconciliationEffects` handle?
- A) Running the reconciler
- B) Processing `Placement` and `ChildDeletion` flags — inserting and removing DOM nodes
- C) Reconciling state
- D) Committing context changes

**Answer: B**
`commitReconciliationEffects` handles `Placement` (insert/move DOM nodes via `commitPlacement`) during the mutation sub-phase.

---

### Q37. What is the `Visibility` flag related to?
- A) CSS visibility property
- B) The Activity/Offscreen component's visibility state changes
- C) Whether the component is in the viewport
- D) DevTools visibility

**Answer: B**
The `Visibility` flag is used by `OffscreenComponent` (Activity) when toggling between visible and hidden states. It triggers visibility-related effect cleanups and setups.

---

### Q38. In React's event system, what is a "dispatch listener"?
- A) A Redux dispatch function
- B) A pair of `{ instance (fiber), listener (handler function), currentTarget }` collected during event dispatch
- C) A DOM event listener
- D) A scheduler callback

**Answer: B**
When an event fires, React walks the fiber tree collecting dispatch listeners — objects containing the fiber instance, the actual handler function, and the currentTarget for that level.

---

### Q39. How does React handle `onFocus` and `onBlur`?
- A) Directly on each element
- B) Using `focusin` and `focusout` for delegation (because `focus`/`blur` don't bubble)
- C) Via `document.activeElement` polling
- D) Using Mutation Observer

**Answer: B**
Since `focus` and `blur` don't bubble, React uses `focusin` and `focusout` (which do bubble) for its event delegation, then maps them to React's `onFocus`/`onBlur`.

---

### Q40. What is the `MountPassive` flag?
- A) Indicates a passive component
- B) Indicates the fiber has passive effects (`useEffect`) that need to be set up on mount
- C) Indicates passive rendering mode
- D) Indicates the DOM is passively mounted

**Answer: B**
`MountPassive` (along with `MountLayout`) marks fibers that have effects needing initial setup during commit. React uses these to efficiently find effects to process.

---

### Q41. What does `resetAfterCommit` do?
- A) Resets the fiber tree
- B) A host config method that restores any state changed during commit (e.g., selection state)
- C) Resets the scheduler
- D) Clears the event queue

**Answer: B**
`resetAfterCommit` is a host config method called after commit completes. In the DOM renderer, it can restore browser state (like text selection) that may have been disrupted.

---

### Q42. How does React batch DOM mutations?
- A) Using `requestAnimationFrame`
- B) All mutations happen in one synchronous commit phase pass — the browser doesn't paint until commit completes
- C) Using a virtual DOM diff
- D) Using DocumentFragment

**Answer: B**
Since commit is synchronous and the browser only paints during idle time (between tasks), all DOM mutations appear as one atomic update to the user.

---

### Q43. What is `prepareForCommit` used for?
- A) Preparing the fiber tree for commit
- B) A host config method that saves DOM state before mutations (like active element, selection range)
- C) Preparing the scheduler
- D) Validating the commit

**Answer: B**
`prepareForCommit` saves state that mutations might disrupt (focused element, selection). `resetAfterCommit` restores it.

---

### Q44. What happens to `useEffect` cleanups when a component tree is deleted?
- A) They run synchronously during commit
- B) They are scheduled to run asynchronously in `flushPassiveEffects`
- C) They never run
- D) They run during the next render

**Answer: B**
Passive effect cleanups for deleted components are scheduled asynchronously, running in the next `flushPassiveEffects` call. Layout effect cleanups, however, run synchronously during deletion.

---

### Q45. What is the order of commit operations for a newly mounted tree?
- A) Layout effects → Mutations → Passive effects
- B) Mutations (insert DOM) → Tree swap → Layout effects (useLayoutEffect, refs) → Paint → Passive effects (useEffect)
- C) Passive effects → Layout effects → Mutations
- D) All happen simultaneously

**Answer: B**
Mount: Insert DOM nodes → swap tree pointer → run layout effects and attach refs → browser paints → run passive effects.

---

### Q46. How does React handle `onChange` for input elements?
- A) Uses the native `change` event directly
- B) Uses a combination of native events (`input`, `change`, `click`, etc.) to provide consistent cross-browser behavior
- C) Polls the input value
- D) Uses `MutationObserver`

**Answer: B**
React's `onChange` fires on every value change (like `input` event), not just on blur (like native `change`). React uses multiple native events to achieve this consistency.

---

### Q47. What is the `Hydrating` flag?
- A) Indicates the component needs water
- B) Indicates the fiber is being hydrated from server-rendered HTML
- C) Indicates the fiber is loading data
- D) Indicates CSS hydration

**Answer: B**
During hydration, fibers get the `Hydrating` flag to indicate they should reuse existing DOM nodes from the server-rendered HTML rather than creating new ones.

---

### Q48. What does `event.isPropagationStopped()` check in React?
- A) If native propagation was stopped
- B) If React's fiber-tree propagation was stopped via `e.stopPropagation()`
- C) If CSS propagation was stopped
- D) If context propagation was stopped

**Answer: B**
React tracks its own propagation state on the SyntheticEvent. `isPropagationStopped()` returns `true` if `stopPropagation()` was called, preventing further fiber-tree handler collection.

---

### Q49. How does React handle `capture` phase events?
- A) Capture events are not supported
- B) React registers separate capture listeners and processes `onClickCapture` handlers during the capture traversal (root → target)
- C) Capture events are converted to bubble events
- D) React simulates capture using timers

**Answer: B**
React registers both capture and bubble listeners at the root. For `onClickCapture`, handlers are collected during a top-down (root → target) traversal of the fiber tree.

---

### Q50. What is the maximum delay between commit and `flushPassiveEffects`?
- A) 0ms (synchronous)
- B) No maximum — it runs when the browser is idle
- C) 16ms (one frame)
- D) Typically very short (via MessageChannel), but React may flush earlier if a new render starts

**Answer: D**
Passive effects are scheduled via `MessageChannel`, so they typically run very soon after paint. However, React also flushes them before starting any new render to ensure consistency.
